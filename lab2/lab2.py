#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  lab2.py
#  
################################################################################
# Lab 2
# =====
# Build a script to SSH into a host, execute a command to retrieve the
# environment variables then search for a series of sensitive information in
# files. The paramiko library is the only third party library in use here.
#
# Core Concepts
# -------------
# * Issuing commands and reading / writing files over SSH
# * Parsing files with regular expressions (regexs)
#
# Hard Mode
# ---------
# 1) Handle authentication errors to prevent stack traces with incorrect passwords.
# 2) Add support for key-based authentication.
# 3) Add support for recursively searching through directories.
#

import argparse
import collections
import functools
import getpass
import re
import sys

import paramiko

Query = collections.namedtuple('Query', ('path', 'regex', 'description'))
queries = (
    Query(
        '/etc/king-phisher/server_config.yml',
        r'^\s+database:\s+(?P<secret>post\S+)$',
        'king-phisher database connection string'
    ),
    Query(
        '/etc/shadow',
        r'^[\w-]+:(?P<secret>\$[^:\s]+):',
        'crypt(3) password'
    ),
    Query(
        '$HOME/.pypirc',
        r'^password[:=]\s+(?P<secret>\S+)$',
        '.pypirc file password'
    )
)

def get_env_vars(ssh_client, with_pty=True):
    stdin, stdout, stderr = ssh_client.exec_command('env', get_pty=with_pty)
    # read and decode the stream to a string using utf-8 encoding
    data = stdout.read().decode('utf-8')
    variables = {}
    for line in data.split('\n'):
        key, _, value = line.partition('=')
        variables[key] = value
    return variables

def _var_repl(env_vars, match):
    var = match.group('variable')
    value = env_vars.get(var)
    if value is None:
        return var
    return value

def expand_vars(string, env_vars=None):
    if env_vars is None:
        env_vars = os.environ
    # create a replacement callback function that uses env_vars as it's first
    # argument, additional arguments will be added after it
    repl_callback = functools.partial(_var_repl, env_vars)
    return re.sub(r'\$(?P<variable>[a-zA-Z]\w*)((?=[\W])|$)', repl_callback, string)

def main():
    # setup the arguments to consume from the command line
    parser = argparse.ArgumentParser(description='ssh file scanner')
    parser.add_argument('-p', '--port', default=22, type=int, help='the port to connect to')
    parser.add_argument('-V', '--verbose', action='store_true', default=False, help='print verbose output')
    parser.add_argument('target', help='the target to connect to')
    args = parser.parse_args()

    # get the username from the target if it's present otherwise use the current
    # user just like ssh does
    if '@' in args.target:
        username, _, target = args.target.partition('@')
    else:
        target = args.target
        username = getpass.getuser()

    password = getpass.getpass("{}@{}'s password: ".format(username, target))

    # define the transport, connect, authenticate and get an sftp client instance
    ssh_client = paramiko.SSHClient()
    ssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    ssh_client.connect(target, port=args.port, username=username, password=password)
    print('successfully authenticated to: ' + target)

    env_vars = get_env_vars(ssh_client)
    print("[*] loaded {:,} environment variables".format(len(env_vars)))
    
    sftp = ssh_client.open_sftp()
    # iterate through each of the quries, open the file if possible and search it
    for query in queries:
        try:
            file_h = sftp.open(query.path)
        except FileNotFoundError:
            if args.verbose:
                print('[-] file not found: ' + query.path)
            continue
        data = file_h.read()
        data = data.decode('utf-8')

        first = True
        for match in re.finditer(query.regex, data, re.MULTILINE):
            if first:
                print("[+] {} ({})".format(query.path, query.description))
            # get the line number by counting the occurances of \n before the match
            line_number = data[:match.span()[0]].count('\n') + 1
            print("    [{: >4}] {}".format(line_number, match.group('secret')))
        file_h.close()
    ssh_client.close()

if __name__ == '__main__':
    main()
